/**
 * @license r.js Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
 * Available via the MIT, GPL or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */

/*jslint nomen: false */
/*global require: true, process: false, global: false, logger: false, commonJs: false */
"use strict";

/*
 This file is an adapter file to allow RequireJS to run in node.
 If you are in the directory that contains the JS file you want node to
 run, then issue this command (assuming you want to run index.js):
 > node path/to/r.js index.js
*/

(function () {
    var fs = require("fs"),
        sys = require("sys"),
        cwd = process.cwd(),
        appFilePath = process.argv[2],
        isDebug = false,
        appDir;

    if (appFilePath === "debug") {
        isDebug = true;
        appFilePath = process.argv[3];
    }

    //Make sure path to app file is absolute.
    if (appFilePath.charAt(0) !== "/") {
        appFilePath = [cwd, appFilePath].join("/");
    }

    //Now get app directory.
    appDir = appFilePath.split("/");
    appDir.pop();
    appDir = appDir.join("/");

    //Create some temporary globals that will be removed by the injected file.
    global.__requireIsDebug = isDebug;
    global.__requireLog = sys.puts;
    global.__requireReadFile = function (path) {
        sys.puts('loading file: ' + path);
        return fs.readFileSync(path);
    };

    //dist.sh will inject the modified requireAdapter content as a string.
    process.compile("/**\n * @license RequireJS requireAdapter Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint nomen: false */\n/*global require: false, process: false */\n\n//>>includeStart(\"useStrict\", pragmas.useStrict);\n\"use strict\";\n//>>includeEnd(\"useStrict\");\n\n/**\n * @license RequireJS Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n//laxbreak is true to allow build pragmas to change some statements.\n/*jslint plusplus: false, laxbreak: true */\n/*global window: false, document: false, navigator: false,\nsetTimeout: false, traceDeps: true, clearInterval: false, self: false,\nsetInterval: false */\n\n//>>includeStart(\"useStrict\", pragmas.useStrict);\n\"use strict\";\n//>>includeEnd(\"useStrict\");\n\nvar require;\n(function () {\n    //Change this version number for each release.\n    var version = \"0.10.0\",\n            empty = {}, s,\n            i, defContextName = \"_\", contextLoads = [],\n            scripts, script, rePkg, src, m, cfg, setReadyState,\n            readyRegExp = /^(complete|loaded)$/,\n            isBrowser = !!(typeof window !== \"undefined\" && navigator && document),\n            ostring = Object.prototype.toString, scrollIntervalId;\n\n    function isFunction(it) {\n        return ostring.call(it) === \"[object Function]\";\n    }\n\n    //Check for an existing version of require. If so, then exit out. Only allow\n    //one version of require to be active in a page. However, allow for a require\n    //config object, just exit quickly if require is an actual function.\n    if (typeof require !== \"undefined\") {\n        if (isFunction(require)) {\n            return;\n        } else {\n            //assume it is a config object.\n            cfg = require;\n        }\n    }\n\n    //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n    function makeContextFunc(name, contextName, force) {\n        return function () {\n            //A version of a require function that uses the current context.\n            //If last arg is a string, then it is a context.\n            //If last arg is not a string, then add context to it.\n            var args = [].concat(Array.prototype.slice.call(arguments, 0));\n            if (force || typeof arguments[arguments.length - 1] !== \"string\") {\n                args.push(contextName);\n            }\n            return (name ? require[name] : require).apply(null, args);\n        };\n    }\n    //>>excludeEnd(\"requireExcludeContext\");\n    \n    //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n    /**\n     * Calls a method on a plugin. The obj object should have two property,\n     * name: the name of the method to call on the plugin\n     * args: the arguments to pass to the plugin method.\n     */\n    function callPlugin(prefix, context, obj) {\n        //Call the plugin, or load it.\n        var plugin = s.plugins.defined[prefix], waiting;\n        if (plugin) {\n            plugin[obj.name].apply(null, obj.args);\n        } else {\n            //Put the call in the waiting call BEFORE requiring the module,\n            //since the require could be synchronous in some environments,\n            //like builds\n            waiting = s.plugins.waiting[prefix] || (s.plugins.waiting[prefix] = []);\n            waiting.push(obj);\n\n            //Load the module\n            context.defined.require([\"require/\" + prefix]);\n        }\n    }\n    //>>excludeEnd(\"requireExcludePlugin\");\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     */\n    require = function (deps, callback, contextName) {\n        if (typeof deps === \"string\" && !isFunction(callback)) {\n            //Just return the module wanted. In this scenario, the\n            //second arg (if passed) is just the contextName.\n            return require.get(deps, callback);\n        }\n\n        //Do more work, either \n        return require.def.apply(require, arguments);\n    };\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument\'s\n     * name.\n     */\n    require.def = function (name, deps, callback, contextName) {\n        var config = null, context, newContext, contextRequire, loaded,\n            canSetContext, prop, newLength, outDeps,\n            mods, pluginPrefix, paths, index, i;\n\n        //Normalize the arguments.\n        if (typeof name === \"string\") {\n            //Defining a module. First, pull off any plugin prefix.\n            index = name.indexOf(\"!\");\n            if (index !== -1) {\n                pluginPrefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n\n            //Check if there are no dependencies, and adjust args.\n            if (!require.isArray(deps)) {\n                contextName = callback;\n                callback = deps;\n                deps = [];\n            }\n\n            contextName = contextName || s.ctxName;\n\n            //If module already defined for context, or already waiting to be\n            //evaluated, leave.\n            context = s.contexts[contextName];\n            if (context && (context.defined[name] || context.waiting[name])) {\n                return require;\n            }\n        } else if (require.isArray(name)) {\n            //Just some code that has dependencies. Adjust args accordingly.\n            contextName = callback;\n            callback = deps;\n            deps = name;\n            name = null;\n        } else if (require.isFunction(name)) {\n            //Just a function that does not define a module and\n            //does not have dependencies. Useful if just want to wait\n            //for whatever modules are in flight and execute some code after\n            //those modules load.\n            callback = name;\n            contextName = deps;\n            name = null;\n            deps = [];\n        } else {\n            //name is a config object.\n            config = name;\n            name = null;\n            //Adjust args if no dependencies.\n            if (require.isFunction(deps)) {\n                contextName = callback;\n                callback = deps;\n                deps = [];\n            }\n\n            contextName = contextName || config.context;\n        }\n\n        contextName = contextName || s.ctxName;\n\n        //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n        if (contextName !== s.ctxName) {\n            //If nothing is waiting on being loaded in the current context,\n            //then switch s.ctxName to current contextName.\n            loaded = (s.contexts[s.ctxName] && s.contexts[s.ctxName].loaded);\n            canSetContext = true;\n            if (loaded) {\n                for (prop in loaded) {\n                    if (!(prop in empty)) {\n                        if (!loaded[prop]) {\n                            canSetContext = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (canSetContext) {\n                s.ctxName = contextName;\n            }\n        }\n        //>>excludeEnd(\"requireExcludeContext\");\n\n        //Grab the context, or create a new one for the given context name.\n        context = s.contexts[contextName];\n        if (!context) {\n            newContext = {\n                contextName: contextName,\n                config: {\n                    waitSeconds: 7,\n                    baseUrl: s.baseUrl || \"./\",\n                    paths: {}\n                },\n                waiting: [],\n                specified: {\n                    \"require\": true,\n                    \"exports\": true,\n                    \"module\": true\n                },\n                loaded: {\n                    \"require\": true\n                },\n                defined: {},\n                modifiers: {}\n            };\n\n            //Define require for this context.\n            //>>includeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n            //A placeholder for build pragmas.\n            newContext.defined.require = require;\n            //>>includeEnd(\"requireExcludeContext\");\n            //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n            newContext.defined.require = contextRequire = makeContextFunc(null, contextName);\n            require.mixin(contextRequire, {\n                //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n                modify: makeContextFunc(\"modify\", contextName),\n                def: makeContextFunc(\"def\", contextName),\n                //>>excludeEnd(\"requireExcludeModify\");\n                get: makeContextFunc(\"get\", contextName, true),\n                nameToUrl: makeContextFunc(\"nameToUrl\", contextName, true),\n                ready: require.ready,\n                context: newContext,\n                config: newContext.config,\n                isBrowser: s.isBrowser\n            });\n            //>>excludeEnd(\"requireExcludeContext\");\n\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            if (s.plugins.newContext) {\n                s.plugins.newContext(newContext);\n            }\n            //>>excludeEnd(\"requireExcludePlugin\");\n\n            context = s.contexts[contextName] = newContext;\n        }\n\n        //If have a config object, update the context\'s config object with\n        //the config values.\n        if (config) {\n            //Make sure the baseUrl ends in a slash.\n            if (config.baseUrl) {\n                if (config.baseUrl.charAt(config.baseUrl.length - 1) !== \"/\") {\n                    config.baseUrl += \"/\";\n                }\n            }\n\n            //Save off the paths since they require special processing,\n            //they are additive.\n            paths = context.config.paths;\n\n            //Mix in the config values, favoring the new values over\n            //existing ones in context.config.\n            require.mixin(context.config, config, true);\n\n            //Adjust paths if necessary.\n            if (config.paths) {\n                for (prop in config.paths) {\n                    if (!(prop in empty)) {\n                        paths[prop] = config.paths[prop];\n                    }\n                }\n                context.config.paths = paths;\n            }\n\n            //If a deps array or a config callback is specified, then call\n            //require with those args. This is useful when require is defined as a\n            //config object before require.js is loaded.\n            if (config.deps || config.callback) {\n                require(config.deps || [], config.callback);\n            }\n\n            //>>excludeStart(\"requireExcludePageLoad\", pragmas.requireExcludePageLoad);\n            //Set up ready callback, if asked. Useful when require is defined as a\n            //config object before require.js is loaded.\n            if (config.ready) {\n                require.ready(config.ready);\n            }\n            //>>excludeEnd(\"requireExcludePageLoad\");\n\n            //If it is just a config block, nothing else,\n            //then return.\n            if (!deps) {\n                return require;\n            }\n        }\n\n        //Normalize dependency strings: need to determine if they have\n        //prefixes and to also normalize any relative paths. Replace the deps\n        //array of strings with an array of objects.\n        if (deps) {\n            outDeps = deps;\n            deps = [];\n            for (i = 0; i < outDeps.length; i++) {\n                deps[i] = require.splitPrefix(outDeps[i], name);\n            }\n        }\n\n        //Store the module for later evaluation\n        newLength = context.waiting.push({\n            name: name,\n            deps: deps,\n            callback: callback\n        });\n\n        if (name) {\n            //Store index of insertion for quick lookup\n            context.waiting[name] = newLength - 1;\n\n            //Mark the module as specified: not loaded yet, but in the process,\n            //so no need to fetch it again. Important to do it here for the\n            //pause/resume case where there are multiple modules in a file.\n            context.specified[name] = true;\n\n            //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n            //Load any modifiers for the module.\n            mods = context.modifiers[name];\n            if (mods) {\n                require(mods, contextName);\n            }\n            //>>excludeEnd(\"requireExcludeModify\");\n        }\n\n        //If the callback is not an actual function, it means it already\n        //has the definition of the module as a literal value.\n        if (name && callback && !require.isFunction(callback)) {\n            context.defined[name] = callback;\n        }\n\n        //If a pluginPrefix is available, call the plugin, or load it.\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        if (pluginPrefix) {\n            callPlugin(pluginPrefix, context, {\n                name: \"require\",\n                args: [name, deps, callback, context]\n            });\n        }\n        //>>excludeEnd(\"requireExcludePlugin\");\n\n        //See if all is loaded. If paused, then do not check the dependencies\n        //of the module yet.\n        if (s.paused) {\n            s.paused.push([pluginPrefix, name, deps, context]);\n        } else {\n            require.checkDeps(pluginPrefix, name, deps, context);\n            require.checkLoaded(contextName);\n        }\n\n        return require;\n    };\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     */\n    require.mixin = function (target, source, override) {\n        for (var prop in source) {\n            if (!(prop in empty) && (!(prop in target) || override)) {\n                target[prop] = source[prop];\n            }\n        }\n        return require;\n    };\n\n    require.version = version;\n\n    //Set up page state.\n    s = require.s = {\n        ctxName: defContextName,\n        contexts: {},\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        plugins: {\n            defined: {},\n            callbacks: {},\n            waiting: {}\n        },\n        //>>excludeEnd(\"requireExcludePlugin\");\n        isBrowser: isBrowser,\n        isPageLoaded: !isBrowser,\n        readyCalls: [],\n        doc: isBrowser ? document : null\n    };\n\n    require.isBrowser = s.isBrowser;\n    s.head = isBrowser ? document.getElementsByTagName(\"head\")[0] : null;\n\n    //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n    /**\n     * Sets up a plugin callback name. Want to make it easy to test if a plugin\n     * needs to be called for a certain lifecycle event by testing for\n     * if (s.plugins.onLifeCyleEvent) so only define the lifecycle event\n     * if there is a real plugin that registers for it.\n     */\n    function makePluginCallback(name, returnOnTrue) {\n        var cbs = s.plugins.callbacks[name] = [];\n        s.plugins[name] = function () {\n            for (var i = 0, cb; (cb = cbs[i]); i++) {\n                if (cb.apply(null, arguments) === true && returnOnTrue) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n\n    /**\n     * Registers a new plugin for require.\n     */\n    require.plugin = function (obj) {\n        var i, prop, call, prefix = obj.prefix, cbs = s.plugins.callbacks,\n            waiting = s.plugins.waiting[prefix], generics,\n            defined = s.plugins.defined, contexts = s.contexts, context;\n\n        //Do not allow redefinition of a plugin, there may be internal\n        //state in the plugin that could be lost.\n        if (defined[prefix]) {\n            return require;\n        }\n\n        //Save the plugin.\n        defined[prefix] = obj;\n\n        //Set up plugin callbacks for methods that need to be generic to\n        //require, for lifecycle cases where it does not care about a particular\n        //plugin, but just that some plugin work needs to be done.\n        generics = [\"newContext\", \"isWaiting\", \"orderDeps\"];\n        for (i = 0; (prop = generics[i]); i++) {\n            if (!s.plugins[prop]) {\n                makePluginCallback(prop, prop === \"isWaiting\");\n            }\n            cbs[prop].push(obj[prop]);\n        }\n\n        //Call newContext for any contexts that were already created.\n        if (obj.newContext) {\n            for (prop in contexts) {\n                if (!(prop in empty)) {\n                    context = contexts[prop];\n                    obj.newContext(context);\n                }\n            }\n        }\n\n        //If there are waiting requests for a plugin, execute them now.\n        if (waiting) {\n            for (i = 0; (call = waiting[i]); i++) {\n                if (obj[call.name]) {\n                    obj[call.name].apply(null, call.args);\n                }\n            }\n            delete s.plugins.waiting[prefix];\n        }\n\n        return require;\n    };\n    //>>excludeEnd(\"requireExcludePlugin\");\n\n    /**\n     * Pauses the tracing of dependencies. Useful in a build scenario when\n     * multiple modules are bundled into one file, and they all need to be\n     * require before figuring out what is left still to load.\n     */\n    require.pause = function () {\n        if (!s.paused) {\n            s.paused = [];\n        }\n    };\n\n    /**\n     * Resumes the tracing of dependencies. Useful in a build scenario when\n     * multiple modules are bundled into one file. This method is related\n     * to require.pause() and should only be called if require.pause() was called first.\n     */\n    require.resume = function () {\n        var i, args, paused;\n        if (s.paused) {\n            paused = s.paused;\n            delete s.paused;\n            for (i = 0; (args = paused[i]); i++) {\n                require.checkDeps.apply(require, args);\n            }\n        }\n        require.checkLoaded(s.ctxName);\n    };\n\n    /**\n     * Trace down the dependencies to see if they are loaded. If not, trigger\n     * the load.\n     * @param {String} pluginPrefix the plugin prefix, if any associated with the name.\n     *\n     * @param {String} name: the name of the module that has the dependencies.\n     *\n     * @param {Array} deps array of dependencies.\n     *\n     * @param {Object} context: the loading context.\n     *\n     * @private\n     */\n    require.checkDeps = function (pluginPrefix, name, deps, context) {\n        //Figure out if all the modules are loaded. If the module is not\n        //being loaded or already loaded, add it to the \"to load\" list,\n        //and request it to be loaded.\n        var i, dep, index, depPrefix, split;\n\n        if (pluginPrefix) {\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            callPlugin(pluginPrefix, context, {\n                name: \"checkDeps\",\n                args: [name, deps, context]\n            });\n            //>>excludeEnd(\"requireExcludePlugin\");\n        } else {\n            for (i = 0; (dep = deps[i]); i++) {\n                if (!context.specified[dep.fullName]) {\n                    context.specified[dep.fullName] = true;\n\n                    //If a plugin, call its load method.\n                    if (dep.prefix) {\n                        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n                        callPlugin(dep.prefix, context, {\n                            name: \"load\",\n                            args: [dep.name, context.contextName]\n                        });\n                        //>>excludeEnd(\"requireExcludePlugin\");\n                    } else {\n                        require.load(dep.name, context.contextName);\n                    }\n                }\n            }\n        }\n    };\n\n    //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n    /**\n     * Register a module that modifies another module. The modifier will\n     * only be called once the target module has been loaded.\n     *\n     * First syntax:\n     *\n     * require.modify({\n     *     \"some/target1\": \"my/modifier1\",\n     *     \"some/target2\": \"my/modifier2\",\n     * });\n     *\n     * With this syntax, the my/modifier1 will only be loaded when\n     * \"some/target1\" is loaded.\n     *\n     * Second syntax, defining a modifier.\n     *\n     * require.modify(\"some/target1\", \"my/modifier\",\n     *                        [\"some/target1\", \"some/other\"],\n     *                        function (target, other) {\n     *                            //Modify properties of target here.\n     *                            Only properties of target can be modified, but\n     *                            target cannot be replaced.\n     *                        }\n     * );\n     */\n    require.modify = function (target, name, deps, callback, contextName) {\n        var prop, modifier, list,\n                cName = (typeof target === \"string\" ? contextName : name) || s.ctxName,\n                context = s.contexts[cName],\n                mods = context.modifiers;\n\n        if (typeof target === \"string\") {\n            //A modifier module.\n            //First store that it is a modifier.\n            list = mods[target] || (mods[target] = []);\n            if (!list[name]) {\n                list.push(name);\n                list[name] = true;\n            }\n\n            //Trigger the normal module definition logic.\n            require.def(name, deps, callback, contextName);\n        } else {\n            //A list of modifiers. Save them for future reference.\n            for (prop in target) {\n                if (!(prop in empty)) {\n                    //Store the modifier for future use.\n                    modifier = target[prop];\n                    list = context.modifiers[prop] || (context.modifiers[prop] = []);\n                    if (!list[modifier]) {\n                        list.push(modifier);\n                        list[modifier] = true;\n\n                        if (context.specified[prop]) {\n                            //Load the modifier right away.\n                            require([modifier], cName);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    //>>excludeEnd(\"requireExcludeModify\");\n\n    require.isArray = function (it) {\n        return ostring.call(it) === \"[object Array]\";\n    };\n\n    require.isFunction = isFunction;\n\n    /**\n     * Gets one module\'s exported value. This method is used by require().\n     * It is broken out as a separate function to allow a host environment\n     * shim to overwrite this function with something appropriate for that\n     * environment.\n     *\n     * @param {String} moduleName the name of the module.\n     * @param {String} [contextName] the name of the context to use. Uses\n     * default context if no contextName is provided.\n     *\n     * @returns {Object} the exported module value.\n     */\n    require.get = function (moduleName, contextName) {\n        if (moduleName === \"exports\" || moduleName === \"module\") {\n            throw new Error(\"require of \" + moduleName + \" is not allowed.\");\n        }\n        contextName = contextName || s.ctxName;\n        var ret = s.contexts[contextName].defined[moduleName];\n        if (ret === undefined) {\n            throw new Error(\"require: module name \'\" +\n                            moduleName +\n                            \"\' has not been loaded yet for context: \" +\n                            contextName);\n        }\n        return ret;\n    };\n\n    /**\n     * Makes the request to load a module. May be an async load depending on\n     * the environment and the circumstance of the load call. Override this\n     * method in a host environment shim to do something specific for that\n     * environment.\n     *\n     * @param {String} moduleName the name of the module.\n     * @param {String} contextName the name of the context to use.\n     */\n    require.load = function (moduleName, contextName) {\n        var context = s.contexts[contextName], url;\n        s.isDone = false;\n        context.loaded[moduleName] = false;\n        //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n        if (contextName !== s.ctxName) {\n            //Not in the right context now, hold on to it until\n            //the current context finishes all its loading.\n            contextLoads.push(arguments);\n        } else {\n        //>>excludeEnd(\"requireExcludeContext\");\n            //First derive the path name for the module.\n            url = require.nameToUrl(moduleName, null, contextName);\n            require.attach(url, contextName, moduleName);\n            context.startTime = (new Date()).getTime();\n        //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n        }\n        //>>excludeEnd(\"requireExcludeContext\");\n    };\n\n    require.jsExtRegExp = /\\.js$/;\n\n    \n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    require.normalizeName = function (name, baseName) {\n        //Adjust any relative paths.\n        var part;\n        if (name.charAt(0) === \".\") {\n            //Convert baseName to array, and lop off the last part,\n            //so that . matches that \"directory\" and not name of the baseName\'s\n            //module. For instance, baseName of \"one/two/three\", maps to\n            //\"one/two/three.js\", but we want the directory, \"one/two\" for\n            //this normalization.\n            baseName = baseName.split(\"/\");\n            baseName = baseName.slice(0, baseName.length - 1);\n\n            name = baseName.concat(name.split(\"/\"));\n            for (i = 0; (part = name[i]); i++) {\n                if (part === \".\") {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === \"..\") {\n                    name.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n            name = name.join(\"/\");\n        }\n        return name;\n    };\n\n    /**\n     * Splits a name into a possible plugin prefix and\n     * the module name. If baseName is provided it will\n     * also normalize the name via require.normalizeName()\n     * \n     * @param {String} name the module name\n     * @param {String} [baseName] base name that name is\n     * relative to.\n     *\n     * @returns {Object} with properties, \'prefix\' (which\n     * may be null), \'name\' and \'fullName\', which is a combination\n     * of the prefix (if it exists) and the name.\n     */\n    require.splitPrefix = function (name, baseName) {\n        var index = name.indexOf(\"!\"), prefix = null;\n        if (index !== -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n\n        //Account for relative paths if there is a base name.\n        if (baseName) {\n            name = require.normalizeName(name, baseName);\n        }\n\n        return {\n            prefix: prefix,\n            name: name,\n            fullName: prefix ? prefix + \"!\" + name : name\n        };\n    };\n\n    /**\n     * Converts a module name to a file path.\n     */\n    require.nameToUrl = function (moduleName, ext, contextName) {\n        var paths, syms, i, parentModule, url,\n            config = s.contexts[contextName].config;\n\n        //If a colon is in the URL, it indicates a protocol is used and it is just\n        //an URL to a file, or if it starts with a slash or ends with .js, it is just a plain file.\n        //The slash is important for protocol-less URLs as well as full paths.\n        if (moduleName.indexOf(\":\") !== -1 || moduleName.charAt(0) === \'/\' || require.jsExtRegExp.test(moduleName)) {\n            //Just a plain path, not module name lookup, so just return it.\n            return moduleName;\n        } else if (moduleName.charAt(0) === \".\") {\n            throw new Error(\"require.nameToUrl does not handle relative module names (ones that start with \'.\' or \'..\')\");\n        } else {\n            //A module that needs to be converted to a path.\n            paths = config.paths;\n\n            syms = moduleName.split(\"/\");\n            //For each module name segment, see if there is a path\n            //registered for it. Start with most specific name\n            //and work up from it.\n            for (i = syms.length; i > 0; i--) {\n                parentModule = syms.slice(0, i).join(\"/\");\n                if (paths[parentModule]) {\n                    syms.splice(0, i, paths[parentModule]);\n                    break;\n                }\n            }\n\n            //Join the path parts together, then figure out if baseUrl is needed.\n            url = syms.join(\"/\") + (ext || \".js\");\n            return ((url.charAt(0) === \'/\' || url.match(/^\\w+:/)) ? \"\" : config.baseUrl) + url;\n        }\n    };\n\n    /**\n     * Checks if all modules for a context are loaded, and if so, evaluates the\n     * new ones in right dependency order.\n     *\n     * @private\n     */\n    require.checkLoaded = function (contextName) {\n        var context = s.contexts[contextName || s.ctxName],\n                waitInterval = context.config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                loaded = context.loaded, defined = context.defined,\n                modifiers = context.modifiers, waiting = context.waiting, noLoads = \"\",\n                hasLoadedProp = false, stillLoading = false, prop,\n\n                //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n                pIsWaiting = s.plugins.isWaiting, pOrderDeps = s.plugins.orderDeps,\n                //>>excludeEnd(\"requireExcludePlugin\");\n\n                i, module, allDone, loads, loadArgs,\n                traced = {};\n\n        //If already doing a checkLoaded call,\n        //then do not bother checking loaded state.\n        if (context.isCheckLoaded) {\n            return;\n        }\n\n        //Signal that checkLoaded is being require, so other calls that could be triggered\n        //by calling a waiting callback that then calls require and then this function\n        //should not proceed. At the end of this function, if there are still things\n        //waiting, then checkLoaded will be called again.\n        context.isCheckLoaded = true;\n\n        //See if anything is still in flight.\n        for (prop in loaded) {\n            if (!(prop in empty)) {\n                hasLoadedProp = true;\n                if (!loaded[prop]) {\n                    if (expired) {\n                        noLoads += prop + \" \";\n                    } else {\n                        stillLoading = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        //Check for exit conditions.\n        if (!hasLoadedProp && !waiting.length\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            && (!pIsWaiting || !pIsWaiting(context))\n            //>>excludeEnd(\"requireExcludePlugin\");\n           ) {\n            //If the loaded object had no items, then the rest of\n            //the work below does not need to be done.\n            context.isCheckLoaded = false;\n            return;\n        }\n        if (expired && noLoads) {\n            //If wait time expired, throw error of unloaded modules.\n            throw new Error(\"require.js load timeout for modules: \" + noLoads);\n        }\n        if (stillLoading) {\n            //Something is still waiting to load. Wait for it.\n            context.isCheckLoaded = false;\n            if (require.isBrowser) {\n                setTimeout(function () {\n                    require.checkLoaded(contextName);\n                }, 50);\n            }\n            return;\n        }\n\n        //Order the dependencies. Also clean up state because the evaluation\n        //of modules might create new loading tasks, so need to reset.\n        //Be sure to call plugins too.\n        context.waiting = [];\n        context.loaded = {};\n\n        //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n        //Call plugins to order their dependencies, do their\n        //module definitions.\n        if (pOrderDeps) {\n            pOrderDeps(context);\n        }\n        //>>excludeEnd(\"requireExcludePlugin\");\n\n        //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n        //Before defining the modules, give priority treatment to any modifiers\n        //for modules that are already defined.\n        for (prop in modifiers) {\n            if (!(prop in empty)) {\n                if (defined[prop]) {\n                    require.execModifiers(prop, traced, waiting, context);\n                }\n            }\n        }\n        //>>excludeEnd(\"requireExcludeModify\");\n\n        //Define the modules, doing a depth first search.\n        for (i = 0; (module = waiting[i]); i++) {\n            require.exec(module, traced, waiting, context);\n        }\n\n        //Indicate checkLoaded is now done.\n        context.isCheckLoaded = false;\n\n        if (context.waiting.length\n            //>>excludeStart(\"requireExcludePlugin\", pragmas.requireExcludePlugin);\n            || (pIsWaiting && pIsWaiting(context))\n            //>>excludeEnd(\"requireExcludePlugin\");\n           ) {\n            //More things in this context are waiting to load. They were probably\n            //added while doing the work above in checkLoaded, calling module\n            //callbacks that triggered other require calls.\n            require.checkLoaded(contextName);\n        } else if (contextLoads.length) {\n            //>>excludeStart(\"requireExcludeContext\", pragmas.requireExcludeContext);\n            //Check for other contexts that need to load things.\n            //First, make sure current context has no more things to\n            //load. After defining the modules above, new require calls\n            //could have been made.\n            loaded = context.loaded;\n            allDone = true;\n            for (prop in loaded) {\n                if (!(prop in empty)) {\n                    if (!loaded[prop]) {\n                        allDone = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allDone) {\n                s.ctxName = contextLoads[0][1];\n                loads = contextLoads;\n                //Reset contextLoads in case some of the waiting loads\n                //are for yet another context.\n                contextLoads = [];\n                for (i = 0; (loadArgs = loads[i]); i++) {\n                    require.load.apply(require, loadArgs);\n                }\n            }\n            //>>excludeEnd(\"requireExcludeContext\");\n        } else {\n            //Make sure we reset to default context.\n            s.ctxName = defContextName;\n            s.isDone = true;\n            if (require.callReady) {\n                require.callReady();\n            }\n        }\n    };\n\n    /**\n     * Executes the modules in the correct order.\n     * \n     * @private\n     */\n    require.exec = function (module, traced, waiting, context) {\n        //Some modules are just plain script files, abddo not have a formal\n        //module definition, \n        if (!module) {\n            return undefined;\n        }\n\n        var name = module.name, cb = module.callback, deps = module.deps, j, dep,\n            defined = context.defined, ret, args = [], prefix, depModule,\n            usingExports = false, depName;\n\n        //If already traced or defined, do not bother a second time.\n        if (name) {\n            if (traced[name] || defined[name]) {\n                return defined[name];\n            }\n    \n            //Mark this module as being traced, so that it is not retraced (as in a circular\n            //dependency)\n            traced[name] = true;\n        }\n\n        if (deps) {\n            for (j = 0; (dep = deps[j]); j++) {\n                depName = dep.name;\n                if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    depModule = defined[name] = {};\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    depModule = {\n                        id: name,\n                        uri: name ? require.nameToUrl(name, null, context.contextName) : undefined\n                    };\n                } else {\n                    //Get dependent module. It could not exist, for a circular\n                    //dependency or if the loaded dependency does not actually call\n                    //require. Favor not throwing an error here if undefined because\n                    //we want to allow code that does not use require as a module\n                    //definition framework to still work -- allow a web site to\n                    //gradually update to contained modules. That is more\n                    //important than forcing a throw for the circular dependency case.\n                    depModule = depName in defined ? defined[depName] : (traced[depName] ? undefined : require.exec(waiting[waiting[depName]], traced, waiting, context));\n                }\n\n                args.push(depModule);\n            }\n        }\n\n        //Call the callback to define the module, if necessary.\n        cb = module.callback;\n        if (cb && require.isFunction(cb)) {\n            ret = require.execCb(name, cb, args);\n            if (name) {\n                if (usingExports) {\n                    ret = defined[name];\n                } else {\n                    if (name in defined) {\n                        throw new Error(name + \" has already been defined\");\n                    } else {\n                        defined[name] = ret;\n                    }\n                }\n            }\n        }\n\n        //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n        //Execute modifiers, if they exist.\n        require.execModifiers(name, traced, waiting, context);\n        //>>excludeEnd(\"requireExcludeModify\");\n\n        return ret;\n    };\n\n    /**\n     * Executes a module callack function. Broken out as a separate function\n     * solely to allow the build system to sequence the files in the built\n     * layer in the right sequence.\n     * @param {String} name the module name.\n     * @param {Function} cb the module callback/definition function.\n     * @param {Array} args The arguments (dependent modules) to pass to callback.\n     *\n     * @private\n     */\n    require.execCb = function (name, cb, args) {\n        return cb.apply(null, args);\n    };\n\n    //>>excludeStart(\"requireExcludeModify\", pragmas.requireExcludeModify);\n    /**\n     * Executes modifiers for the given module name.\n     * @param {String} target\n     * @param {Object} traced\n     * @param {Object} context\n     *\n     * @private\n     */\n    require.execModifiers = function (target, traced, waiting, context) {\n        var modifiers = context.modifiers, mods = modifiers[target], mod, i;\n        if (mods) {\n            for (i = 0; i < mods.length; i++) {\n                mod = mods[i];\n                //Not all modifiers define a module, they might collect other modules.\n                //If it is just a collection it will not be in waiting.\n                if (mod in waiting) {\n                    require.exec(waiting[waiting[mod]], traced, waiting, context);\n                }\n            }\n            delete modifiers[target];\n        }\n    };\n    //>>excludeEnd(\"requireExcludeModify\");\n\n    /**\n     * callback for script loads, used to check status of loading.\n     *\n     * @param {Event} evt the event from the browser for the script\n     * that was loaded.\n     *\n     * @private\n     */\n    require.onScriptLoad = function (evt) {\n        var node = evt.target || evt.srcElement, contextName, moduleName;\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\n            //Pull out the name of the module and the context.\n            contextName = node.getAttribute(\"data-requirecontext\");\n            moduleName = node.getAttribute(\"data-requiremodule\");\n\n            //Mark the module loaded.\n            s.contexts[contextName].loaded[moduleName] = true;\n\n            require.checkLoaded(contextName);\n\n            //Clean up script binding.\n            if (node.removeEventListener) {\n                node.removeEventListener(\"load\", require.onScriptLoad, false);\n            } else {\n                //Probably IE.\n                node.detachEvent(\"onreadystatechange\", require.onScriptLoad);\n            }\n        }\n    };\n\n    /**\n     * Attaches the script represented by the URL to the current\n     * environment. Right now only supports browser loading,\n     * but can be redefined in other environments to do the right thing.\n     */\n    require.attach = function (url, contextName, moduleName) {\n        if (require.isBrowser) {\n            var node = document.createElement(\"script\");\n            node.type = \"text/javascript\";\n            node.charset = \"utf-8\";\n            node.setAttribute(\"data-requirecontext\", contextName);\n            node.setAttribute(\"data-requiremodule\", moduleName);\n    \n            //Set up load listener.\n            if (node.addEventListener) {\n                node.addEventListener(\"load\", require.onScriptLoad, false);\n            } else {\n                //Probably IE.\n                node.attachEvent(\"onreadystatechange\", require.onScriptLoad);\n            }\n            node.src = url;\n\n            return s.head.appendChild(node);\n        }\n        return null;\n    };\n\n    //Determine what baseUrl should be if not already defined via a require config object\n    s.baseUrl = cfg && cfg.baseUrl;\n    if (require.isBrowser && (!s.baseUrl || !s.head)) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        scripts = document.getElementsByTagName(\"script\");\n        if (cfg && cfg.baseUrlMatch) {\n            rePkg = cfg.baseUrlMatch;\n        } else {\n            //>>includeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(requireplugins-|require-)?jquery[\\-\\d\\.]*(min)?\\.js(\\W|$)/i;\n            //>>includeEnd(\"jquery\");\n\n            //>>includeStart(\"dojoConvert\", pragmas.dojoConvert);\n            rePkg = /dojo\\.js(\\W|$)/i;\n            //>>includeEnd(\"dojoConvert\");\n\n            //>>excludeStart(\"dojoConvert\", pragmas.dojoConvert);\n\n            //>>excludeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(allplugins-)?require\\.js(\\W|$)/i;\n            //>>excludeEnd(\"jquery\");\n\n            //>>excludeEnd(\"dojoConvert\");\n        }\n\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            //Set the \"head\" where we can append children by\n            //using the script\'s parent.\n            if (!s.head) {\n                s.head = script.parentNode;\n            }\n            //Using .src instead of getAttribute to get an absolute URL.\n            //While using a relative URL will be fine for script tags, other\n            //URLs used for text! resources that use XHR calls might benefit\n            //from an absolute URL.\n            src = script.src;\n            if (src) {\n                m = src.match(rePkg);\n                if (m) {\n                    s.baseUrl = src.substring(0, m.index);\n                    break;\n                }\n            }\n        }\n    }\n\n    //>>excludeStart(\"requireExcludePageLoad\", pragmas.requireExcludePageLoad);\n    //****** START page load functionality ****************\n    /**\n     * Sets the page as loaded and triggers check for all modules loaded.\n     */\n    require.pageLoaded = function () {\n        if (!s.isPageLoaded) {\n            s.isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            //Part of a fix for FF < 3.6 where readyState was not set to\n            //complete so libraries like jQuery that check for readyState\n            //after page load where not getting initialized correctly.\n            //Original approach suggested by Andrea Giammarchi:\n            //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n            //see other setReadyState reference for the rest of the fix.\n            if (setReadyState) {\n                document.readyState = \"complete\";\n            }\n\n            require.callReady();\n        }\n    };\n\n    /**\n     * Internal function that calls back any ready functions. If you are\n     * integrating RequireJS with another library without require.ready support,\n     * you can define this method to call your page ready code instead.\n     */\n    require.callReady = function () {\n        var callbacks = s.readyCalls, i, callback;\n\n        if (s.isPageLoaded && s.isDone && callbacks.length) {\n            s.readyCalls = [];\n            for (i = 0; (callback = callbacks[i]); i++) {\n                callback();\n            }\n        }\n    };\n\n    /**\n     * Registers functions to call when the page is loaded\n     */\n    require.ready = function (callback) {\n        if (s.isPageLoaded && s.isDone) {\n            callback();\n        } else {\n            s.readyCalls.push(callback);\n        }\n        return require;\n    };\n\n    if (require.isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", require.pageLoaded, false);\n            window.addEventListener(\"load\", require.pageLoaded, false);\n            //Part of FF < 3.6 readystate fix (see setReadyState refs for more info)\n            if (!document.readyState) {\n                setReadyState = true;\n                document.readyState = \"loading\";\n            }\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", require.pageLoaded);\n\n            //DOMContentLoaded approximation, as found by Diego Perini:\n            //http://javascript.nwbox.com/IEContentLoaded/\n            if (self === self.top) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        document.documentElement.doScroll(\"left\");\n                        require.pageLoaded();\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. NOTE: does not work with Firefox before 3.6. To support\n        //those browsers, manually call require.pageLoaded().\n        if (document.readyState === \"complete\") {\n            require.pageLoaded();\n        }\n    }\n    //****** END page load functionality ****************\n    //>>excludeEnd(\"requireExcludePageLoad\");\n\n    //Set up default context. If require was a configuration object, use that as base config.\n    if (cfg) {\n        require(cfg);\n    }\n}());\n\n/**\n * @license RequireJS i18n Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, navigator: false */\n\n//>>includeStart(\"useStrict\", pragmas.useStrict);\n\"use strict\";\n//>>includeEnd(\"useStrict\");\n\n/**\n * This plugin handles i18n! prefixed modules. It does the following:\n *\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\n * module does not want to specify what locale to load. So it just specifies\n * the top-level bundle, like \"i18n!nls/colors\".\n *\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\n * bundle since it does not have a locale in its name. It will then try to find\n * the best match locale available in that master bundle, then request all the\n * locale pieces for that best match locale. For instance, if the locale is \"en-us\",\n * then the plugin will ask for the \"en-us\", \"en\" and \"root\" bundles to be loaded\n * (but only if they are specified on the master bundle).\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/colors bundle to be that mixed in locale.\n *\n * 2) A regular module specifies a specific locale to load. For instance,\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\n * since maybe only fr or just root is defined for that locale. Once that best\n * fit is found, all of its locale pieces need to have their bundles loaded.\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\n */\n(function () {\n    //regexp for reconstructing the master bundle name from parts of the regexp match\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\n    //so, if match[5] is blank, it means this is the top bundle definition.\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/,\n        empty = {};\n\n    function getWaiting(name, context) {\n        var nlswAry = context.nlsWaiting;\n        return nlswAry[name] ||\n               //Push a new waiting object on the nlsWaiting array, but also put\n               //a shortcut lookup by name to the object on the array.\n               (nlswAry[name] = nlswAry[(nlswAry.push({ _name: name}) - 1)]);\n    }\n\n    /**\n     * Makes sure all the locale pieces are loaded, and finds the best match\n     * for the requested locale.\n     */\n    function resolveLocale(masterName, bundle, locale, context) {\n        //Break apart the locale to get the parts.\n        var i, parts, toLoad, nlsw, loc, val, bestLoc = \"root\";\n\n        parts = locale.split(\"-\");\n\n        //Now see what bundles exist for each country/locale.\n        //Want to walk up the chain, so if locale is en-us-foo,\n        //look for en-us-foo, en-us, en, then root.\n        toLoad = [];\n\n        nlsw = getWaiting(masterName, context);\n\n        for (i = parts.length; i > -1; i--) {\n            loc = i ? parts.slice(0, i).join(\"-\") : \"root\";\n            val = bundle[loc];\n            if (val) {\n                //Store which bundle to use for the default bundle definition.\n                if (locale === context.config.locale && !nlsw._match) {\n                    nlsw._match = loc;\n                }\n\n                //Store the best match for the target locale\n                if (bestLoc === \"root\") {\n                    bestLoc = loc;\n                }\n\n                //Track that the locale needs to be resolved with its parts.\n                //Mark what locale should be used when resolving.\n                nlsw[loc] = loc;\n\n                //If locale value is true, it means it is a resource that\n                //needs to be loaded. Track it to load if it has not already\n                //been asked for.\n                if (val === true) {\n                    //split off the bundl name from master name and insert the\n                    //locale before the bundle name. So, if masterName is\n                    //some/path/nls/colors, then the locale fr-fr\'s bundle name should\n                    //be some/path/nls/fr-fr/colors\n                    val = masterName.split(\"/\");\n                    val.splice(-1, 0, loc);\n                    val = val.join(\"/\");\n\n                    if (!context.specified[val] && !(val in context.loaded) && !context.defined[val]) {\n                        toLoad.push(val);\n                    }\n                }\n            }\n        }\n\n        //If locale was not an exact match, store the closest match for it.\n        if (bestLoc !== locale) {\n            if (context.defined[bestLoc]) {\n                //Already got it. Easy peasy lemon squeezy.\n                context.defined[locale] = context.defined[bestLoc];\n            } else {\n                //Need to wait for things to load then define it.\n                nlsw[locale] = bestLoc;\n            }\n        }\n\n        //Load any bundles that are still needed.\n        if (toLoad.length) {\n            context.defined.require(toLoad);\n        }\n    }\n\n    require.plugin({\n        prefix: \"i18n\",\n\n        /**\n         * This callback is prefix-specific, only gets called for this prefix\n         */\n        require: function (name, deps, callback, context) {\n            var i, match, nlsw, bundle, master, toLoad, obj = context.defined[name];\n\n            //All i18n modules must match the nls module name structure.\n            match = nlsRegExp.exec(name);\n            //If match[5] is blank, it means this is the top bundle definition,\n            //so it does not have to be handled. Only deal with ones that have a locale\n            //(a match[4] value but no match[5])\n            if (match[5]) {\n                master = match[1] + match[5];\n\n                //Track what locale bundle need to be generated once all the modules load.\n                nlsw = getWaiting(master, context);\n                nlsw[match[4]] = match[4];\n\n                bundle = context.nls[master];\n                if (!bundle) {\n                    //No master bundle yet, ask for it.\n                    context.defined.require([master]);\n                    bundle = context.nls[master] = {};\n                }\n                //For nls modules, the callback is just a regular object,\n                //so save it off in the bundle now.\n                bundle[match[4]] = callback;\n            } else {\n                //Integrate bundle into the nls area.\n                bundle = context.nls[name];\n                if (bundle) {\n                    //A specific locale already started the bundle object.\n                    //Do a mixin (which will not overwrite the locale property\n                    //on the bundle that has the previously loaded locale\'s info)\n                    require.mixin(bundle, obj);\n                } else {\n                    bundle = context.nls[name] = obj;\n                }\n                context.nlsRootLoaded[name] = true;\n\n                //Make sure there are no locales waiting to be resolved.\n                toLoad = context.nlsToLoad[name];\n                if (toLoad) {\n                    delete context.nlsToLoad[name];\n                    for (i = 0; i < toLoad.length; i++) {\n                        resolveLocale(name, bundle, toLoad[i], context);\n                    }\n                }\n\n                resolveLocale(name, bundle, context.config.locale, context);\n            }\n        },\n\n        /**\n         * Called when a new context is defined. Use this to store\n         * context-specific info on it.\n         */\n        newContext: function (context) {\n            require.mixin(context, {\n                nlsWaiting: [],\n                nls: {},\n                nlsRootLoaded: {},\n                nlsToLoad: {}\n            });\n            if (!context.config.locale) {\n                context.config.locale = typeof navigator === \"undefined\" ? \"root\" :\n                        (navigator.language || navigator.userLanguage || \"root\").toLowerCase();\n            }\n        },\n\n        /**\n         * Called when a dependency needs to be loaded.\n         */\n        load: function (name, contextName) {\n            //Make sure the root bundle is loaded, to check if we can support\n            //loading the requested locale, or if a different one needs\n            //to be chosen.\n            var masterName, context = require.s.contexts[contextName], bundle,\n                match = nlsRegExp.exec(name), locale = match[4];\n\n            //If match[5] is blank, it means this is the top bundle definition,\n            //so it does not have to be handled. Only deal with ones that have a locale\n            //(a match[4] value but no match[5])\n            if (match[5]) {\n                //locale-specific bundle\n                masterName = match[1] + match[5];\n                bundle = context.nls[masterName];\n                if (context.nlsRootLoaded[masterName] && bundle) {\n                    resolveLocale(masterName, bundle, locale, context);\n                } else {\n                    //Store this locale to figure out after masterName is loaded and load masterName.\n                    (context.nlsToLoad[masterName] || (context.nlsToLoad[masterName] = [])).push(locale);\n                    context.defined.require([masterName]);\n                }\n            } else {\n                //Top-level bundle. Just call regular load, if not already loaded\n                if (!context.nlsRootLoaded[name]) {\n                    require.load(name, contextName);\n                }\n            }\n        },\n\n        /**\n         * Called when the dependencies of a module are checked.\n         */\n        checkDeps: function (name, deps, context) {\n            //i18n bundles are always defined as objects for their \"dependencies\",\n            //and that object is already processed in the require method, no need to\n            //do work in here.\n        },\n\n        /**\n         * Called to determine if a module is waiting to load.\n         */\n        isWaiting: function (context) {\n            return !!context.nlsWaiting.length;\n        },\n\n        /**\n         * Called when all modules have been loaded.\n         */\n        orderDeps: function (context) {\n            //Clear up state since further processing could\n            //add more things to fetch.\n            var i, j, master, msWaiting, bundle, parts, moduleSuffix, mixed,\n                modulePrefix, loc, defLoc, locPart, nlsWaiting = context.nlsWaiting,\n                bestFit;\n            context.nlsWaiting = [];\n            context.nlsToLoad = {};\n\n            //First, properly mix in any nls bundles waiting to happen.\n            for (i = 0; (msWaiting = nlsWaiting[i]); i++) {\n                //Each property is a master bundle name.\n                master = msWaiting._name;\n                bundle = context.nls[master];\n                defLoc = null;\n\n                //Create the module name parts from the master name. So, if master\n                //is foo/nls/bar, then the parts should be prefix: \"foo/nls\",\n                // suffix: \"bar\", and the final locale\'s module name will be foo/nls/locale/bar\n                parts = master.split(\"/\");\n                modulePrefix = parts.slice(0, parts.length - 1).join(\"/\");\n                moduleSuffix = parts[parts.length - 1];\n                //Cycle through the locale props on the waiting object and combine\n                //the locales together.\n                for (loc in msWaiting) {\n                    if (loc !== \"_name\" && !(loc in empty)) {\n                        if (loc === \"_match\") {\n                            //Found default locale to use for the top-level bundle name.\n                            defLoc = msWaiting[loc];\n                        \n                        } else if (msWaiting[loc] !== loc) {\n                            //A \"best fit\" locale, store it off to the end and handle\n                            //it at the end by just assigning the best fit value, since\n                            //after this for loop, the best fit locale will be defined.\n                            (bestFit || (bestFit = {}))[loc] = msWaiting[loc];\n                        } else {\n                            //Mix in the properties of this locale together.\n                            //Split the locale into pieces.\n                            mixed = {};\n                            parts = loc.split(\"-\");\n                            for (j = parts.length; j > 0; j--) {\n                                locPart = parts.slice(0, j).join(\"-\");\n                                if (locPart !== \"root\" && bundle[locPart]) {\n                                    require.mixin(mixed, bundle[locPart]);\n                                }\n                            }\n                            if (bundle.root) {\n                                require.mixin(mixed, bundle.root);\n                            }\n\n                            context.defined[modulePrefix + \"/\" + loc + \"/\" + moduleSuffix] = mixed;\n                        }\n                    }\n                }\n\n                //Finally define the default locale. Wait to the end of the property\n                //loop above so that the default locale bundle has been properly mixed\n                //together.\n                context.defined[master] = context.defined[modulePrefix + \"/\" + defLoc + \"/\" + moduleSuffix];\n                \n                //Handle any best fit locale definitions.\n                if (bestFit) {\n                    for (loc in bestFit) {\n                        if (!(loc in empty)) {\n                            context.defined[modulePrefix + \"/\" + loc + \"/\" + moduleSuffix] = context.defined[modulePrefix + \"/\" + bestFit[loc] + \"/\" + moduleSuffix];\n                        }\n                    }\n                }\n            }\n        }\n    });\n}());\n\n/**\n * @license RequireJS text Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, XMLHttpRequest: false, ActiveXObject: false */\n\n//>>includeStart(\"useStrict\", pragmas.useStrict);\n\"use strict\";\n//>>includeEnd(\"useStrict\");\n\n(function () {\n    var progIds = [\'Msxml2.XMLHTTP\', \'Microsoft.XMLHTTP\', \'Msxml2.XMLHTTP.4.0\'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\\'\\\"](\\d)*.(\\d)*[\\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im;\n\n    if (!require.textStrip) {\n        require.textStrip = function (text) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (text) {\n                text = text.replace(xmlRegExp, \"\");\n                var matches = text.match(bodyRegExp);\n                if (matches) {\n                    text = matches[1];\n                }\n            } else {\n                text = \"\";\n            }\n            return text;\n        };\n    }\n\n    //Upgrade require to add some methods for XHR handling. But it could be that\n    //this require is used in a non-browser env, so detect for existing method\n    //before attaching one.\n    if (!require.getXhr) {\n        require.getXhr = function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else {\n                for (i = 0; i < 3; i++) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }   \n            }\n\n            if (!xhr) {\n                throw new Error(\"require.getXhr(): XMLHttpRequest not available\");\n            }\n\n            return xhr;\n        };\n    }\n    \n    if (!require.fetchText) {\n        require.fetchText = function (url, callback) {\n            var xhr = require.getXhr();\n            xhr.open(\'GET\', url, true);\n            xhr.onreadystatechange = function (evt) {\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    callback(xhr.responseText);\n                }\n            };\n            xhr.send(null);\n        };\n    }\n\n    require.plugin({\n        prefix: \"text\",\n\n        /**\n         * This callback is prefix-specific, only gets called for this prefix\n         */\n        require: function (name, deps, callback, context) {\n            //No-op, require never gets these text items, they are always\n            //a dependency, see load for the action.\n        },\n\n        /**\n         * Called when a new context is defined. Use this to store\n         * context-specific info on it.\n         */\n        newContext: function (context) {\n            require.mixin(context, {\n                text: {},\n                textWaiting: []\n            });\n        },\n\n        /**\n         * Called when a dependency needs to be loaded.\n         */\n        load: function (name, contextName) {\n            //Name has format: some.module!filext!strip!text\n            //The strip and text parts are optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n            //If text is present, it is the actual text of the file.\n            var strip = false, text = null, key, url, index = name.indexOf(\".\"),\n                modName = name.substring(0, index), fullKey,\n                ext = name.substring(index + 1, name.length),\n                context = require.s.contexts[contextName],\n                tWaitAry = context.textWaiting;\n\n            index = ext.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = ext.substring(index + 1, ext.length);\n                ext = ext.substring(0, index);\n                index = strip.indexOf(\"!\");\n                if (index !== -1 && strip.substring(0, index) === \"strip\") {\n                    //Pull off the text.\n                    text = strip.substring(index + 1, strip.length);\n                    strip = \"strip\";\n                } else if (strip !== \"strip\") {\n                    //strip is actually the inlined text.\n                    text = strip;\n                    strip = null;\n                }\n            }\n            key = modName + \"!\" + ext;\n            fullKey = strip ? key + \"!\" + strip : key;\n\n            //Store off text if it is available for the given key and be done.\n            if (text !== null && !context.text[key]) {\n                context.defined[name] = context.text[key] = text;\n                return;\n            }\n\n            //If text is not available, load it.\n            if (!context.text[key] && !context.textWaiting[key] && !context.textWaiting[fullKey]) {\n                //Keep track that the fullKey needs to be resolved, during the\n                //orderDeps stage.\n                if (!tWaitAry[fullKey]) {\n                    tWaitAry[fullKey] = tWaitAry[(tWaitAry.push({\n                        name: name,\n                        key: key,\n                        fullKey: fullKey,\n                        strip: !!strip\n                    }) - 1)];\n                }\n\n                //Load the text.\n                url = require.nameToUrl(modName, \".\" + ext, contextName);\n                context.loaded[name] = false;\n                require.fetchText(url, function (text) {\n                    context.text[key] = text;\n                    context.loaded[name] = true;\n                    require.checkLoaded(contextName);                    \n                });\n            }\n        },\n\n        /**\n         * Called when the dependencies of a module are checked.\n         */\n        checkDeps: function (name, deps, context) {\n            //No-op, checkDeps never gets these text items, they are always\n            //a dependency, see load for the action.\n        },\n\n        /**\n         * Called to determine if a module is waiting to load.\n         */\n        isWaiting: function (context) {\n            return !!context.textWaiting.length;\n        },\n\n        /**\n         * Called when all modules have been loaded.\n         */\n        orderDeps: function (context) {\n            //Clear up state since further processing could\n            //add more things to fetch.\n            var i, dep, text, tWaitAry = context.textWaiting;\n            context.textWaiting = [];\n            for (i = 0; (dep = tWaitAry[i]); i++) {\n                text = context.text[dep.key];\n                context.defined[dep.name] = dep.strip ? require.textStrip(text) : text;\n            }\n        }\n    });\n}());\n\n\n(function () {\n    /**\n * @license RequireJS Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\nvar logger = {\n\tTRACE: 0,\n\tINFO: 1,\n\tWARN: 2,\n\tERROR: 3,\n\tlevel: 0,\n\tlogPrefix: \"\",\n\n\ttrace: function(message){\n\t\tif(this.level <= this.TRACE){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\tinfo: function(message){\n\t\tif(this.level <= this.INFO){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\twarn: function(message){\n\t\tif(this.level <= this.WARN){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\terror: function(message){\n\t\tif(this.level <= this.ERROR){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\t_print: function(message){\n\t\tthis._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n\t},\n\n        _sysPrint: function(message){\n            print(message);\n        }\n}\n\n/**\n * @license RequireJS Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT, GPL or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint plusplus: false, regexp: false */\n/*global Packages: false, logger: false, fileUtil: false */\n\"use strict\";\n\nvar commonJs = {\n    depRegExp: /require\\s*\\(\\s*[\"\']([\\w-_\\.\\/]+)[\"\']\\s*\\)/g,\n\n    //Set this to false in non-rhino environments. If rhino, then it uses\n    //rhino\'s decompiler to remove comments before looking for require() calls,\n    //otherwise, it will use a crude regexp approach to remove comments. The\n    //rhino way is more robust, but he regexp is more portable across environments.\n    useRhino: true,\n\n    //Set to false if you do not want this file to log. Useful in environments\n    //like node where you want the work to happen without noise.\n    useLog: true,\n\n    //Set to true to see full converted module contents logged to output.\n    logConverted: false,\n\n    convertDir: function (commonJsPath, savePath, prefix) {\n        //Normalize prefix\n        prefix = prefix ? prefix + \"/\" : \"\";\n\n        var fileList, i,\n            jsFileRegExp = /\\.js$/,\n            fileName, moduleName, convertedFileName, fileContents;\n\n        //Get list of files to convert.\n        fileList = fileUtil.getFilteredFileList(commonJsPath, /\\w/, true);\n        \n        //Normalize on front slashes and make sure the paths do not end in a slash.\n        commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n        savePath = savePath.replace(/\\\\/g, \"/\");\n        if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n            commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n        }\n        if (savePath.charAt(savePath.length - 1) === \"/\") {\n            savePath = savePath.substring(0, savePath.length - 1);\n        }\n        \n        //Cycle through all the JS files and convert them.\n        if (!fileList || !fileList.length) {\n            if (commonJsPath === \"convert\") {\n                //A request just to convert one file.\n                logger.trace(\'\\n\\n\' + commonJs.convert(savePath, fileUtil.readFile(savePath)));\n            } else {\n                logger.error(\"No files to convert in directory: \" + commonJsPath);\n            }\n        } else {\n            for (i = 0; (fileName = fileList[i]); i++) {\n                //Handle JS files.\n                if (jsFileRegExp.test(fileName)) {\n                    convertedFileName = fileName.replace(commonJsPath, savePath);\n                    moduleName = fileName.replace(commonJsPath + \"/\", \"\").replace(/\\.js$/, \"\");\n        \n                    fileContents = fileUtil.readFile(fileName);\n                    fileContents = commonJs.convert(prefix + moduleName, fileName, fileContents);\n                    fileUtil.saveUtf8File(convertedFileName, fileContents);\n                } else {\n                    //Just copy the file over.\n                    fileUtil.copyFile(fileName, convertedFileName, true);\n                }\n            }\n        }\n    },\n\n    /**\n     * Removes the comments from a string. Uses a more robust method if\n     * Rhino is available, otherwise a cruder regexp is used. If the regexp\n     * is used, then the contents may not be executable, but hopefully good\n     * enough to use to find require() calls.\n     * \n     * @param {String} fileContents\n     * @param {String} fileName mostly used for informative reasons if an error.\n     * \n     * @returns {String} a string of JS with comments removed.\n     */\n    removeComments: function (fileContents, fileName) {\n        var context, script;\n        if (commonJs.useRhino) {\n            context = Packages.org.mozilla.javascript.Context.enter();\n            script = context.compileString(fileContents, fileName, 1, null);\n            return String(context.decompileScript(script, 0));\n        } else {\n            return fileContents.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\");\n        }\n    },\n\n    /**\n     * Regexp for testing if there is already a require.def call in the file,\n     * in which case do not try to convert it.\n     */\n    defRegExp: /require\\s*\\.\\s*def\\s*\\(/,\n\n    /**\n     * Regexp for testing if there is a require([]) or require(function(){})\n     * call, indicating the file is already in requirejs syntax.\n     */\n    rjsRegExp: /require\\s*\\(\\s*(\\[|function)/,\n\n    /**\n     * Does the actual file conversion.\n     *\n     * @param {String} moduleName the name of the module to use for the\n     * require.def call.\n     * \n     * @param {String} fileName the name of the file.\n     * \n     * @param {String} fileContents the contents of a file :)\n     *\n     * @returns {String} the converted contents\n     */\n    convert: function (moduleName, fileName, fileContents) {\n        //Strip out comments.\n        if (commonJs.useLog) {\n            logger.trace(\"fileName: \" + fileName);\n        }\n        try {\n            var i, deps = [], depName, origDepName, part, pathConverted = {},\n                prop, reqRegExp, match,\n                //Remove comments\n                tempContents = commonJs.removeComments(fileContents, fileName),\n                baseName = moduleName.split(\"/\");\n\n            //First see if the module is not already RequireJS-formatted.\n            if (commonJs.defRegExp.test(tempContents) || commonJs.rjsRegExp.test(tempContents)) {\n                return fileContents;\n            }\n\n            //Set baseName to be one directory higher than moduleName.\n            baseName.pop();\n    \n            //Reset the regexp to start at beginning of file. Do this\n            //since the regexp is reused across files.\n            commonJs.depRegExp.lastIndex = 0;\n\n            //Find dependencies in the code that was not in comments.\n            while ((match = commonJs.depRegExp.exec(tempContents))) {\n                depName = match[1];\n                if (commonJs.useLog) {\n                    logger.trace(\"  \" + depName);\n                }\n                if (depName) {\n                    //Adjust any relative paths.\n                    if (depName.charAt(0) === \".\") {\n                        origDepName = depName;\n                        depName = baseName.concat(depName.split(\"/\"));\n                        for (i = 0; (part = depName[i]); i++) {\n                            if (part === \".\") {\n                                depName.splice(i, 1);\n                                i -= 1;\n                            } else if (part === \"..\") {\n                                depName.splice(i - 1, 2);\n                                i -= 2;\n                            }\n                        }\n                        depName = depName.join(\"/\");\n                        pathConverted[origDepName] = depName;\n                    }\n                    deps.push(\'\"\' + depName + \'\"\');\n                }\n            }\n    \n            //Convert file content references that used a relative module name\n            //reference to be a more complete module name. Note that above we used\n            //content that had comments removed, now we are dealing with the original\n            //contents with comments, and that is why this is a separate, more expensive\n            //pass vs. uses a fileContents.replace() with a function.\n            for (prop in pathConverted) {\n                if (pathConverted.hasOwnProperty(prop)) {\n                    reqRegExp = new RegExp(\'require\\\\s*\\\\(\\\\s*[\\\'\"]\' + prop + \'[\\\'\"]\\\\s*\\\\)\', \'g\');\n                    fileContents = fileContents.replace(reqRegExp, \'require(\"\' + pathConverted[prop] + \'\")\');\n                }\n            }\n\n            //Construct the wrapper boilerplate.\n            fileContents = \'require.def(\"\' + moduleName + \'\", [\"require\", \"exports\", \"module\"\' +\n                   (deps.length ? \', \' + deps.join(\",\") : \'\') + \'], \' +\n                   \'function(require, exports, module) {\\n\' +\n                   (commonJs.logConverted ? \'global._requirejs_logger.trace(\"Evaluatind module: \' + moduleName + \'\");\\n\' : \"\") +\n                   fileContents +\n                   \'\\n});\\n\';\n        } catch (e) {\n            logger.error(\"COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n            return fileContents;\n        }\n\n        if (commonJs.logConverted) {\n            logger.trace(\"\\nREQUIREJS CONVERTED MODULE: \" + moduleName + \"\\n\\n\" + fileContents + \"\\n\");\n        }\n        return fileContents;\n    }\n};\n\n\n    var natives = process.binding(\'natives\'),\n        isDebug = global.__requireIsDebug;\n\n    //TODO: make this async. Using sync now to cheat to get to a bootstrap.\n    require.load = function (moduleName, contextName) {\n        var url = require.nameToUrl(moduleName, null, contextName),\n            context = require.s.contexts[contextName],\n            content;\n\n        //isDone is used by require.ready()\n        require.s.isDone = false;\n\n        //Indicate a the module is in process of loading.\n        context.loaded[moduleName] = false;\n\n        //Load the content for the module. Be sure to first check the natives\n        //modules that are burned into node first.\n        if (natives[moduleName]) {\n            content = natives[moduleName];\n        } else {\n            content = require._nodeReadFile(url);\n        }\n\n        //If a CommonJS module, translate it on the fly.\n        //The commonJs module is from build/jslib/commonJs.js\n        content = commonJs.convert(moduleName, url, content);\n\n        //TODO: remove when node code is updated:\n        //sys has an obsolete circular ref to child_process. Remove it.\n        if (moduleName === \"sys\") {\n            content = content.replace(/,\\s*\"child_process\"/, \"\");\n        }\n\n        if (isDebug) {\n            logger.trace(\"RequireJS about to evaluate module: \" + moduleName);\n        }\n        process.compile(content, url);\n\n        //Mark the module loaded.\n        context.loaded[moduleName] = true;\n    };\n\n    //Do some patch-ups\n    logger._sysPrint = global.__requireLog;\n    commonJs.useRhino = false;\n\n    //Set useLog to true if some modules do not seem to convert.\n    commonJs.useLog = false;\n    if (isDebug) {\n        commonJs.useLog = true;\n        commonJs.logConverted = true;\n        global._requirejs_logger = logger;\n    }\n\n    require._log = global.__requireLog;\n    require._nodeReadFile = global.__requireReadFile;\n\n    delete global.__requireReadFile;\n    delete global.__requireLog;\n    delete global.__requireIsDebug;\n}());\n\n\n", "requirejs/requireAdapter.js");

    //Set the baseUrl to be the app directory, and pass in the paths.
    process.compile("require({baseUrl: '" + appDir + "'});", "baseUrl");

    //Showtime!
    process.compile(fs.readFileSync(appFilePath), appFilePath);
}());
